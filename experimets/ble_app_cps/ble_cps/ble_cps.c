/* This file was generated by plugin 'Nordic Semiconductor nRF5x v.1.2.4' (BDS version 1.1.3139.0) */

#include "ble_cps.h"
#include <string.h>
#include "nordic_common.h"
#include "ble_srv_common.h"
#include "app_util.h"
#include "app_util_bds.h"

#define OPCODE_LENGTH 1 /**< Length of opcode inside Cycling Power packet. */
#define HANDLE_LENGTH 2 /**< Length of handle inside Cycling Power packet. */

/* TODO Consider changing the max values if encoded data for characteristic/descriptor is fixed length */ 
#define MAX_CYCLING_POWER_MEASUREMENT_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Cycling Power Measurement. */ 
#define MAX_SERVER_CHARACTERISTIC_CONFIGURATION_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Server Characteristic Configuration. */ 
#define MAX_CYCLING_POWER_FEATURE_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Cycling Power Feature. */ 
#define MAX_SENSOR_LOCATION_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Sensor Location. */ 
#define MAX_CYCLING_POWER_VECTOR_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Cycling Power Vector. */ 
#define MAX_CYCLING_POWER_CONTROL_POINT_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Cycling Power Control Point. */ 

#define C1_required 0
#define C2_required 0
#define C3_required 0
#define C4_required 0
#define C5_required 0

/**@brief Function for encoding Flags.
 *
 * @param[in]   p_flags              Flags structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t cycling_power_measurement_flags_encode(cycling_power_measurement_flags_t * p_flags, uint8_t * encoded_buffer)
{
    uint16_t flags;
    flags = flags | (p_flags->pedal_power_balance_present << 0); 
    flags = flags | (p_flags->pedal_power_balance_reference << 1); 
    flags = flags | (p_flags->accumulated_torque_present << 2); 
    flags = flags | (p_flags->accumulated_torque_source << 3); 
    flags = flags | (p_flags->wheel_revolution_data_present << 4); 
    flags = flags | (p_flags->crank_revolution_data_present << 5); 
    flags = flags | (p_flags->extreme_force_magnitudes_present << 6); 
    flags = flags | (p_flags->extreme_torque_magnitudes_present << 7); 
    flags = flags | (p_flags->extreme_angles_present << 8); 
    flags = flags | (p_flags->top_dead_spot_angle_present << 9); 
    flags = flags | (p_flags->bottom_dead_spot_angle_present << 10); 
    flags = flags | (p_flags->accumulated_energy_present << 11); 
    flags = flags | (p_flags->offset_compensation_indicator_ << 12); 

    return bds_uint16_encode(&flags, &encoded_buffer[0]); 
}

/**@brief Function for encoding Cycling Power Measurement.
 *
 * @param[in]   p_cycling_power_measurement              Cycling Power Measurement characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t cycling_power_measurement_encode(ble_cps_cycling_power_measurement_t * p_cycling_power_measurement, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += cycling_power_measurement_flags_encode(&p_cycling_power_measurement->flags, &encoded_buffer[len]); 
    len += bds_int16_encode(&p_cycling_power_measurement->instantaneous_power, &encoded_buffer[len]); 
    encoded_buffer[len++] = p_cycling_power_measurement->pedal_power_balance;
    len += bds_uint16_encode(&p_cycling_power_measurement->accumulated_torque, &encoded_buffer[len]); 
    if (C1_required)
    {
        len += bds_uint32_encode(&p_cycling_power_measurement->wheel_revolution_data___cumulative_wheel_revolutions, &encoded_buffer[len]); 
    } 
    if (C1_required)
    {
        len += bds_uint16_encode(&p_cycling_power_measurement->wheel_revolution_data___last_wheel_event_time, &encoded_buffer[len]); 
    } 
    if (C2_required)
    {
        len += bds_uint16_encode(&p_cycling_power_measurement->crank_revolution_data__cumulative_crank_revolutions, &encoded_buffer[len]); 
    } 
    if (C2_required)
    {
        len += bds_uint16_encode(&p_cycling_power_measurement->crank_revolution_data__last_crank_event_time, &encoded_buffer[len]); 
    } 
    if (C3_required)
    {
        len += bds_int16_encode(&p_cycling_power_measurement->extreme_force_magnitudes___maximum_force_magnitude, &encoded_buffer[len]); 
    } 
    if (C3_required)
    {
        len += bds_int16_encode(&p_cycling_power_measurement->extreme_force_magnitudes___minimum_force_magnitude, &encoded_buffer[len]); 
    } 
    if (C4_required)
    {
        len += bds_int16_encode(&p_cycling_power_measurement->extreme_torque_magnitudes__maximum_torque_magnitude, &encoded_buffer[len]); 
    } 
    if (C4_required)
    {
        len += bds_int16_encode(&p_cycling_power_measurement->extreme_torque_magnitudes__minimum_torque_magnitude, &encoded_buffer[len]); 
    } 
    if (C5_required)
    {
        len += bds_uint8_array_encode(&p_cycling_power_measurement->extreme_angles___maximum_angle, &encoded_buffer[len]); 
    } 
    if (C5_required)
    {
        len += bds_uint8_array_encode(&p_cycling_power_measurement->extreme_angles___minimum_angle, &encoded_buffer[len]); 
    } 
    len += bds_uint16_encode(&p_cycling_power_measurement->top_dead_spot_angle, &encoded_buffer[len]); 
    len += bds_uint16_encode(&p_cycling_power_measurement->bottom_dead_spot_angle, &encoded_buffer[len]); 
    len += bds_uint16_encode(&p_cycling_power_measurement->accumulated_energy, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for encoding Properties.
 *
 * @param[in]   p_properties              Properties structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t server_characteristic_configuration_properties_encode(cps_server_characteristic_configuration_properties_t * p_properties, uint8_t * encoded_buffer)
{
    uint16_t properties;
    properties = properties | (p_properties->cycling_power_properties_bit_0 << 0); 

    return bds_uint16_encode(&properties, &encoded_buffer[0]); 
}

    
/**@brief Function for encoding Server Characteristic Configuration.
 *
 * @param[in]   p_server_characteristic_configuration              Server Characteristic Configuration descriptor structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t server_characteristic_configuration_encode(ble_cps_server_characteristic_configuration_t * p_server_characteristic_configuration, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += server_characteristic_configuration_properties_encode(&p_server_characteristic_configuration->properties, &encoded_buffer[len]); 
    return len;
}
    
 /**@brief Function for decoding Properties.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
 static uint8_t server_characteristic_configuration_properties_decode(uint8_t data_len, uint8_t * p_data, cps_server_characteristic_configuration_properties_t * p_write_val)
 {
    uint8_t pos = 0; 
    p_write_val->cycling_power_properties_bit_0 = (enum_properties_cycling_power_properties_bit_0_t)(p_data[pos] & (0x01 <<  0));
    pos += sizeof(uint16_t);
    return pos;
 }

         
/**@brief Function for decoding Server Characteristic Configuration.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t server_characteristic_configuration_decode(uint8_t data_len, uint8_t * p_data, ble_cps_server_characteristic_configuration_t * p_write_val)
{
    uint8_t pos = 0;
    pos += server_characteristic_configuration_properties_decode((data_len-pos), &p_data[pos], &p_write_val->properties); 

    return pos;
} 
/**@brief Function for encoding Cycling Power Feature.
 *
 * @param[in]   p_cycling_power_feature              Cycling Power Feature structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t cycling_power_feature_cycling_power_feature_encode(cycling_power_feature_cycling_power_feature_t * p_cycling_power_feature, uint8_t * encoded_buffer)
{
    uint32_t cycling_power_feature;
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->pedal_power_balance_supported << 0); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->accumulated_torque_supported << 1); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->wheel_revolution_data_supported << 2); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->crank_revolution_data_supported << 3); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->extreme_magnitudes_supported << 4); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->extreme_angles_supported << 5); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->top_and_bottom_dead_spot_angles_supported << 6); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->accumulated_energy_supported << 7); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->offset_compensation_indicator_supported << 8); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->offset_compensation_supported << 9); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->cycling_power_measurement_characteristic_content_masking_supported << 10); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->multiple_sensor_locations_supported << 11); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->crank_length_adjustment_supported_ << 12); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->chain_length_adjustment_supported << 13); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->chain_weight_adjustment_supported << 14); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->span_length_adjustment_supported << 15); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->sensor_measurement_context << 16); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->instantaneous_measurement_direction_supported << 17); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->factory_calibration_date_supported << 18); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->enhanced_offset_compensation_supported << 19); 
    cycling_power_feature = cycling_power_feature | (p_cycling_power_feature->distribute_system_support << 20); 

    return bds_uint32_encode(&cycling_power_feature, &encoded_buffer[0]); 
}

/**@brief Function for encoding Cycling Power Feature.
 *
 * @param[in]   p_cycling_power_feature              Cycling Power Feature characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t cycling_power_feature_encode(ble_cps_cycling_power_feature_t * p_cycling_power_feature, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += cycling_power_feature_cycling_power_feature_encode(&p_cycling_power_feature->cycling_power_feature, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for encoding Sensor Location.
 *
 * @param[in]   p_sensor_location              Sensor Location structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t sensor_location_sensor_location_encode(sensor_location_sensor_location_t * p_sensor_location, uint8_t * encoded_buffer)
{
    uint8_t sensor_location;
    sensor_location = p_sensor_location->sensor_location;
    encoded_buffer[0] = sensor_location;
    return 1; 
}

/**@brief Function for encoding Sensor Location.
 *
 * @param[in]   p_sensor_location              Sensor Location characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t sensor_location_encode(ble_cps_sensor_location_t * p_sensor_location, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += sensor_location_sensor_location_encode(&p_sensor_location->sensor_location, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for encoding Flags.
 *
 * @param[in]   p_flags              Flags structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t cycling_power_vector_flags_encode(cycling_power_vector_flags_t * p_flags, uint8_t * encoded_buffer)
{
    uint8_t flags;
    flags = flags | (p_flags->crank_revolution_data_present << 0); 
    flags = flags | (p_flags->first_crank_measurement_angle_present << 1); 
    flags = flags | (p_flags->instantaneous_force_magnitude_array_present << 2); 
    flags = flags | (p_flags->instantaneous_torque_magnitude_array_present << 3); 
    flags = flags | (p_flags->instantaneous_measurement_direction << 4); 
    encoded_buffer[0] = flags;
    return 1; 
}

/**@brief Function for encoding Cycling Power Vector.
 *
 * @param[in]   p_cycling_power_vector              Cycling Power Vector characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t cycling_power_vector_encode(ble_cps_cycling_power_vector_t * p_cycling_power_vector, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += cycling_power_vector_flags_encode(&p_cycling_power_vector->flags, &encoded_buffer[len]); 
    if (C1_required)
    {
        len += bds_uint16_encode(&p_cycling_power_vector->crank_revolution_data___cumulative_crank_revolutions, &encoded_buffer[len]); 
    } 
    if (C1_required)
    {
        len += bds_uint16_encode(&p_cycling_power_vector->crank_revolution_data___last_crank_event_time, &encoded_buffer[len]); 
    } 
    len += bds_uint16_encode(&p_cycling_power_vector->first_crank_measurement_angle_, &encoded_buffer[len]); 
    if (C2_required)
    {
        len += bds_int16_encode(&p_cycling_power_vector->instantaneous_force_magnitude_array, &encoded_buffer[len]); 
    } 
    if (C2_required)
    {
        len += bds_int16_encode(&p_cycling_power_vector->instantaneous_torque_magnitude_array, &encoded_buffer[len]); 
    } 
    return len;
}

/**@brief Function for encoding Op Codes.
 *
 * @param[in]   p_op_codes              Op Codes structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t cycling_power_control_point_op_codes_encode(cycling_power_control_point_op_codes_t * p_op_codes, uint8_t * encoded_buffer)
{
    uint8_t op_codes;
    op_codes = p_op_codes->op_codes;
    encoded_buffer[0] = op_codes;
    return 1; 
}

/**@brief Function for encoding Response Value.
 *
 * @param[in]   p_response_value              Response Value structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t cycling_power_control_point_response_value_encode(cycling_power_control_point_response_value_t * p_response_value, uint8_t * encoded_buffer)
{
    uint8_t response_value;
    response_value = p_response_value->response_value;
    encoded_buffer[0] = response_value;
    return 1; 
}

/**@brief Function for encoding Cycling Power Control Point.
 *
 * @param[in]   p_cycling_power_control_point              Cycling Power Control Point characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t cycling_power_control_point_encode(ble_cps_cycling_power_control_point_t * p_cycling_power_control_point, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += cycling_power_control_point_op_codes_encode(&p_cycling_power_control_point->op_codes, &encoded_buffer[len]); 
    len += bds_uint8_array_encode(&p_cycling_power_control_point->parameter_value, &encoded_buffer[len]); 
    if (C1_required)
    {
        encoded_buffer[len++] = p_cycling_power_control_point->request_op_code;
    } 
    if (C1_required)
    {
        len += cycling_power_control_point_response_value_encode(&p_cycling_power_control_point->response_value, &encoded_buffer[len]); 
    } 
    if (C2_required)
    {
        len += bds_uint8_array_encode(&p_cycling_power_control_point->response_parameter, &encoded_buffer[len]); 
    } 
    return len;
}

/**@brief Function for decoding Op Codes.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
 static uint8_t cycling_power_control_point_op_codes_decode(uint8_t data_len, uint8_t * p_data, cycling_power_control_point_op_codes_t * p_write_val)
 {
    uint8_t pos = 0; 
    p_write_val->op_codes = (enum_op_codes_t)p_data[pos++]; 
    return pos;
 }
     
/**@brief Function for decoding Response Value.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
 static uint8_t cycling_power_control_point_response_value_decode(uint8_t data_len, uint8_t * p_data, cycling_power_control_point_response_value_t * p_write_val)
 {
    uint8_t pos = 0; 
    p_write_val->response_value = (enum_response_value_t)p_data[pos++]; 
    return pos;
 }
     
/**@brief Function for decoding Cycling Power Control Point.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t cycling_power_control_point_decode(uint8_t data_len, uint8_t * p_data, ble_cps_cycling_power_control_point_t * p_write_val)
{
    uint8_t pos = 0;
    pos += cycling_power_control_point_op_codes_decode((data_len-pos), &p_data[pos], &p_write_val->op_codes); 
    pos += bds_uint8_array_decode((data_len-pos), &p_data[pos], &p_write_val->parameter_value); 
    if (C1_required)
        { 
        p_write_val->request_op_code = p_data[pos++]; 
        } 
    if (C1_required)
        { 
        pos += cycling_power_control_point_response_value_decode((data_len-pos), &p_data[pos], &p_write_val->response_value); 
        } 
    if (C2_required)
        { 
        pos += bds_uint8_array_decode((data_len-pos), &p_data[pos], &p_write_val->response_parameter); 
        } 

    return pos;
} 

/**@brief Function for handling the Connect event.
 *
 * @param[in]   p_cps       Cycling Power Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_connect(ble_cps_t * p_cps, ble_evt_t * p_ble_evt)
{
    p_cps->conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
}

/**@brief Function for handling the Disconnect event.
 *
 * @param[in]   p_cps       Cycling Power Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_disconnect(ble_cps_t * p_cps, ble_evt_t * p_ble_evt)
{
    UNUSED_PARAMETER(p_ble_evt);
    p_cps->conn_handle = BLE_CONN_HANDLE_INVALID;
}

/**@brief Function for handling the Write event.
 *
 * @param[in]   p_cps       Cycling Power Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_write(ble_cps_t * p_cps, ble_gatts_evt_write_t * p_ble_evt)
{
    
    if(p_ble_evt->handle == p_cps->cycling_power_measurement_handles.cccd_handle)
    {
        if(p_cps->evt_handler != NULL)
        {
            ble_cps_evt_t evt;
            evt.evt_type = BLE_CPS_CYCLING_POWER_MEASUREMENT_EVT_CCCD_WRITE;
            bds_uint16_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.cccd_value);
            p_cps->evt_handler(p_cps, &evt);
        }
    } 
    if(p_ble_evt->handle == p_cps->cycling_power_vector_handles.cccd_handle)
    {
        if(p_cps->evt_handler != NULL)
        {
            ble_cps_evt_t evt;
            evt.evt_type = BLE_CPS_CYCLING_POWER_VECTOR_EVT_CCCD_WRITE;
            bds_uint16_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.cccd_value);
            p_cps->evt_handler(p_cps, &evt);
        }
    } 
    if(p_ble_evt->handle == p_cps->cycling_power_control_point_handles.cccd_handle)
    {
        if(p_cps->evt_handler != NULL)
        {
            ble_cps_evt_t evt;
            evt.evt_type = BLE_CPS_CYCLING_POWER_CONTROL_POINT_EVT_CCCD_WRITE;
            bds_uint16_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.cccd_value);
            p_cps->evt_handler(p_cps, &evt);
        }
    } 
    if(p_ble_evt->handle == p_cps->cycling_power_control_point_handles.value_handle)
    {
        if(p_cps->evt_handler != NULL)
        {
            ble_cps_evt_t evt;
            evt.evt_type = BLE_CPS_CYCLING_POWER_CONTROL_POINT_EVT_WRITE;
            cycling_power_control_point_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.cycling_power_control_point);
            p_cps->evt_handler(p_cps, &evt);
        }
    }
}

/**@brief Authorize WRITE request event handler.
 *
 * @details Handles WRITE events from the BLE stack.
 *
 * @param[in]   p_sc_ctrlpt  SC Ctrlpt structure.
 * @param[in]   p_gatts_evt  GATTS Event received from the BLE stack.
 *
 */
static void on_rw_authorize_request(ble_cps_t * p_cps, ble_gatts_evt_t * p_gatts_evt)
{
    ble_gatts_evt_rw_authorize_request_t * p_auth_req = &p_gatts_evt->params.authorize_request;
    if (p_auth_req->type == BLE_GATTS_AUTHORIZE_TYPE_WRITE)
    {
        if (   (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_PREP_WRITE_REQ)
            && (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_EXEC_WRITE_REQ_NOW)
            && (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL)
           )
        {
        
            if (p_auth_req->request.write.handle == p_cps->cycling_power_control_point_handles.value_handle)
            {
                on_write(p_cps, &p_auth_req->request.write);
            }
        }
    }
}

/**@brief Function for handling BLE events.
 *
 * @param[in]   p_cps       Cycling Power Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
void ble_cps_on_ble_evt(ble_cps_t * p_cps, ble_evt_t * p_ble_evt)
{
    switch (p_ble_evt->header.evt_id)
    {
        case BLE_GAP_EVT_CONNECTED:
            on_connect(p_cps, p_ble_evt);
            break;
        case BLE_GAP_EVT_DISCONNECTED:
            on_disconnect(p_cps, p_ble_evt);
            break;
        case BLE_GATTS_EVT_WRITE:
            on_write(p_cps, &p_ble_evt->evt.gatts_evt.params.write);
            break;
         case BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST:
            on_rw_authorize_request(p_cps, &p_ble_evt->evt.gatts_evt);
            break;
        default:
            //No implementation needed.
            break;
    }
}

/**@brief Function for initializing the Cycling Power. */
uint32_t ble_cps_init(ble_cps_t * p_cps, const ble_cps_init_t * p_cps_init)
{
    uint32_t err_code;
    ble_uuid_t ble_uuid;

    // Initialize service structure
    p_cps->evt_handler = p_cps_init->evt_handler;
    p_cps->conn_handle = BLE_CONN_HANDLE_INVALID;
    
    BLE_UUID_BLE_ASSIGN(ble_uuid, 0x1818);
        
    // Add service
    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_cps->service_handle);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Cycling Power Measurement characteristic
    ble_cps_cycling_power_measurement_t cycling_power_measurement_initial_value = p_cps_init->ble_cps_cycling_power_measurement_initial_value; 

    uint8_t cycling_power_measurement_encoded_value[MAX_CYCLING_POWER_MEASUREMENT_LEN];
    ble_add_char_params_t add_cycling_power_measurement_params;
    memset(&add_cycling_power_measurement_params, 0, sizeof(add_cycling_power_measurement_params));
    
    add_cycling_power_measurement_params.uuid                = 0x2A63; 
    add_cycling_power_measurement_params.max_len             = MAX_CYCLING_POWER_MEASUREMENT_LEN;
    add_cycling_power_measurement_params.init_len            = cycling_power_measurement_encode(&cycling_power_measurement_initial_value, cycling_power_measurement_encoded_value);
    add_cycling_power_measurement_params.p_init_value        = cycling_power_measurement_encoded_value; 
    add_cycling_power_measurement_params.char_props.notify   = 1; 
    add_cycling_power_measurement_params.cccd_write_access   = SEC_OPEN;
    // 1 for variable length and 0 for fixed length.
    add_cycling_power_measurement_params.is_var_len          = 1; 

    err_code = characteristic_add(p_cps->service_handle, &add_cycling_power_measurement_params, &(p_cps->cycling_power_measurement_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Server Characteristic Configuration descriptor 
    ble_add_descr_params_t   server_characteristic_configuration;
    uint16_t                 descr_handle;
    uint8_t                  descr_val[MAX_SERVER_CHARACTERISTIC_CONFIGURATION_LEN];

    memset(&server_characteristic_configuration, 0, sizeof(server_characteristic_configuration));

    server_characteristic_configuration.uuid             = BLE_UUID_REPORT_REF_DESCR;
    server_characteristic_configuration.read_access      = SEC_OPEN;
    server_characteristic_configuration.write_access     = SEC_NO_ACCESS;
    server_characteristic_configuration.init_len         = MAX_SERVER_CHARACTERISTIC_CONFIGURATION_LEN;
    server_characteristic_configuration.max_len          = MAX_SERVER_CHARACTERISTIC_CONFIGURATION_LEN;
    server_characteristic_configuration.p_value          = descr_val;

    err_code = descriptor_add(BLE_GATT_HANDLE_INVALID, &server_characteristic_configuration, &descr_handle);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }
    

    // Add Cycling Power Feature characteristic
    ble_cps_cycling_power_feature_t cycling_power_feature_initial_value = p_cps_init->ble_cps_cycling_power_feature_initial_value; 

    uint8_t cycling_power_feature_encoded_value[MAX_CYCLING_POWER_FEATURE_LEN];
    ble_add_char_params_t add_cycling_power_feature_params;
    memset(&add_cycling_power_feature_params, 0, sizeof(add_cycling_power_feature_params));
    
    add_cycling_power_feature_params.uuid                = 0x2A65; 
    add_cycling_power_feature_params.max_len             = MAX_CYCLING_POWER_FEATURE_LEN;
    add_cycling_power_feature_params.init_len            = cycling_power_feature_encode(&cycling_power_feature_initial_value, cycling_power_feature_encoded_value);
    add_cycling_power_feature_params.p_init_value        = cycling_power_feature_encoded_value; 
    add_cycling_power_feature_params.char_props.read     = 1; 
    add_cycling_power_feature_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_cycling_power_feature_params.is_var_len          = 1; 

    err_code = characteristic_add(p_cps->service_handle, &add_cycling_power_feature_params, &(p_cps->cycling_power_feature_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Sensor Location characteristic
    ble_cps_sensor_location_t sensor_location_initial_value = p_cps_init->ble_cps_sensor_location_initial_value; 

    uint8_t sensor_location_encoded_value[MAX_SENSOR_LOCATION_LEN];
    ble_add_char_params_t add_sensor_location_params;
    memset(&add_sensor_location_params, 0, sizeof(add_sensor_location_params));
    
    add_sensor_location_params.uuid                = 0x2A5D; 
    add_sensor_location_params.max_len             = MAX_SENSOR_LOCATION_LEN;
    add_sensor_location_params.init_len            = sensor_location_encode(&sensor_location_initial_value, sensor_location_encoded_value);
    add_sensor_location_params.p_init_value        = sensor_location_encoded_value; 
    add_sensor_location_params.char_props.read     = 1; 
    add_sensor_location_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_sensor_location_params.is_var_len          = 1; 

    err_code = characteristic_add(p_cps->service_handle, &add_sensor_location_params, &(p_cps->sensor_location_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Cycling Power Vector characteristic
    ble_cps_cycling_power_vector_t cycling_power_vector_initial_value = p_cps_init->ble_cps_cycling_power_vector_initial_value; 

    uint8_t cycling_power_vector_encoded_value[MAX_CYCLING_POWER_VECTOR_LEN];
    ble_add_char_params_t add_cycling_power_vector_params;
    memset(&add_cycling_power_vector_params, 0, sizeof(add_cycling_power_vector_params));
    
    add_cycling_power_vector_params.uuid                = 0x2A64; 
    add_cycling_power_vector_params.max_len             = MAX_CYCLING_POWER_VECTOR_LEN;
    add_cycling_power_vector_params.init_len            = cycling_power_vector_encode(&cycling_power_vector_initial_value, cycling_power_vector_encoded_value);
    add_cycling_power_vector_params.p_init_value        = cycling_power_vector_encoded_value; 
    add_cycling_power_vector_params.char_props.notify   = 1; 
    add_cycling_power_vector_params.cccd_write_access   = SEC_OPEN;
    // 1 for variable length and 0 for fixed length.
    add_cycling_power_vector_params.is_var_len          = 1; 

    err_code = characteristic_add(p_cps->service_handle, &add_cycling_power_vector_params, &(p_cps->cycling_power_vector_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Cycling Power Control Point characteristic
    ble_cps_cycling_power_control_point_t cycling_power_control_point_initial_value = p_cps_init->ble_cps_cycling_power_control_point_initial_value; 

    uint8_t cycling_power_control_point_encoded_value[MAX_CYCLING_POWER_CONTROL_POINT_LEN];
    ble_add_char_params_t add_cycling_power_control_point_params;
    memset(&add_cycling_power_control_point_params, 0, sizeof(add_cycling_power_control_point_params));
    
    add_cycling_power_control_point_params.uuid                = 0x2A66; 
    add_cycling_power_control_point_params.max_len             = MAX_CYCLING_POWER_CONTROL_POINT_LEN;
    add_cycling_power_control_point_params.init_len            = cycling_power_control_point_encode(&cycling_power_control_point_initial_value, cycling_power_control_point_encoded_value);
    add_cycling_power_control_point_params.p_init_value        = cycling_power_control_point_encoded_value; 
    add_cycling_power_control_point_params.char_props.indicate = 1; 
    add_cycling_power_control_point_params.char_props.write    = 1; 
    add_cycling_power_control_point_params.write_access        = SEC_OPEN; 
    add_cycling_power_control_point_params.cccd_write_access   = SEC_OPEN;
    // 1 for variable length and 0 for fixed length.
    add_cycling_power_control_point_params.is_var_len          = 1; 

    err_code = characteristic_add(p_cps->service_handle, &add_cycling_power_control_point_params, &(p_cps->cycling_power_control_point_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    return NRF_SUCCESS;
}

/**@brief Function for sending the Cycling Power Measurement. */
uint32_t ble_cps_cycling_power_measurement_send(ble_cps_t * p_cps, ble_cps_cycling_power_measurement_t * p_cycling_power_measurement)
{
    uint32_t err_code = NRF_SUCCESS;

    if (p_cps->conn_handle != BLE_CONN_HANDLE_INVALID)
    {
        ble_gatts_hvx_params_t hvx_params;
        uint8_t encoded_value[MAX_CYCLING_POWER_MEASUREMENT_LEN];
        uint16_t hvx_len;

        // Initialize value struct.
        memset(&hvx_params, 0, sizeof(hvx_params));

        hvx_len           = cycling_power_measurement_encode(p_cycling_power_measurement, encoded_value);
        hvx_params.handle = p_cps->cycling_power_measurement_handles.value_handle;
        hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;
        hvx_params.p_len  = &hvx_len;
        hvx_params.offset = 0;
        hvx_params.p_data = encoded_value;

        err_code = sd_ble_gatts_hvx(p_cps->conn_handle, &hvx_params);
    }
    else
    {
        err_code = NRF_ERROR_INVALID_STATE;
    }

    return err_code;
}

/**@brief Function for setting the Cycling Power Feature. */
uint32_t ble_cps_cycling_power_feature_set(ble_cps_t * p_cps, ble_cps_cycling_power_feature_t * p_cycling_power_feature)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_CYCLING_POWER_FEATURE_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = cycling_power_feature_encode(p_cycling_power_feature, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_cps->conn_handle, p_cps->cycling_power_feature_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the Sensor Location. */
uint32_t ble_cps_sensor_location_set(ble_cps_t * p_cps, ble_cps_sensor_location_t * p_sensor_location)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_SENSOR_LOCATION_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = sensor_location_encode(p_sensor_location, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_cps->conn_handle, p_cps->sensor_location_handles.value_handle, &gatts_value);
}

/**@brief Function for sending the Cycling Power Vector. */
uint32_t ble_cps_cycling_power_vector_send(ble_cps_t * p_cps, ble_cps_cycling_power_vector_t * p_cycling_power_vector)
{
    uint32_t err_code = NRF_SUCCESS;

    if (p_cps->conn_handle != BLE_CONN_HANDLE_INVALID)
    {
        ble_gatts_hvx_params_t hvx_params;
        uint8_t encoded_value[MAX_CYCLING_POWER_VECTOR_LEN];
        uint16_t hvx_len;

        // Initialize value struct.
        memset(&hvx_params, 0, sizeof(hvx_params));

        hvx_len           = cycling_power_vector_encode(p_cycling_power_vector, encoded_value);
        hvx_params.handle = p_cps->cycling_power_vector_handles.value_handle;
        hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;
        hvx_params.p_len  = &hvx_len;
        hvx_params.offset = 0;
        hvx_params.p_data = encoded_value;

        err_code = sd_ble_gatts_hvx(p_cps->conn_handle, &hvx_params);
    }
    else
    {
        err_code = NRF_ERROR_INVALID_STATE;
    }

    return err_code;
}

/**@brief Function for sending the Cycling Power Control Point. */
uint32_t ble_cps_cycling_power_control_point_send(ble_cps_t * p_cps, ble_cps_cycling_power_control_point_t * p_cycling_power_control_point)
{
    uint32_t err_code = NRF_SUCCESS;

    if (p_cps->conn_handle != BLE_CONN_HANDLE_INVALID)
    {
        ble_gatts_hvx_params_t hvx_params;
        uint8_t encoded_value[MAX_CYCLING_POWER_CONTROL_POINT_LEN];
        uint16_t hvx_len;

        // Initialize value struct.
        memset(&hvx_params, 0, sizeof(hvx_params));

        hvx_len           = cycling_power_control_point_encode(p_cycling_power_control_point, encoded_value);
        hvx_params.handle = p_cps->cycling_power_control_point_handles.value_handle;
        hvx_params.type   = BLE_GATT_HVX_INDICATION;
        hvx_params.p_len  = &hvx_len;
        hvx_params.offset = 0;
        hvx_params.p_data = encoded_value;

        err_code = sd_ble_gatts_hvx(p_cps->conn_handle, &hvx_params);
    }
    else
    {
        err_code = NRF_ERROR_INVALID_STATE;
    }

    return err_code;
}

